#!/bin/bash
# define_funcs

# remember to source this BEFORE you try to export the stuff

# Complex `s3cmd` wrapper:
function s3cmd {
	# define keys if needed:
	if [ -z "$AWS_SECRET_KEY" ]; then
		both=`gpg -o- ~/.aws/keys.gpg 2>/dev/null`
		export AWS_ACCESS_KEY=`echo "$both" | awk "NR==1"`
		export AWS_SECRET_KEY=`echo "$both" | awk "NR==2"`
	fi
	options=$"--access_key=$AWS_ACCESS_KEY --secret_key=$AWS_SECRET_KEY --config=~/.s3cfg"
	if (( $# == 2 )) && [ "$1" = "du" ]; then
		options="$options du $2"
		echo "$options" > options.tmp
		output=`command s3cmd $options 2>/dev/null`
		echo "$output" | cut -d ' ' -f 1 | sed -e 's/^/scale=2; /' -e 's/$/\/1024^2/' | bc | sed 's/$/ MB/'
	else
		options="$options ""$@"
		command s3cmd $options
	fi
}

# Move current working directory up one or more levels:
function up {
	rungnum=1 # how many ladder-rungs to climb, default just 1 level if no args
	path="`pwd`"
	while getopts ":S123456789" opt; do
		if [[ "$opt" == "S" ]]; then
			path="`pwd -P`"
			shift # allow rungnum to be picked up as $1 below
		elif [[ "$opt" == '?' ]]; then
			echo 'up usage: up [-S] [levels]'
			echo 'levels specifies how many times to go up a directory.'
			echo -n '-S does an absolute ascent (resolves symbolic links in path)'
			kill -INT $$
		fi
	done
	if (( $# > 0 )); then
		rungnum=$1 	
	fi
	declare -a ladder
	while [ "$path" != "/" ]; do
		ladder+=($path)
		path=`dirname "$path"`
	done
	cd "${ladder[$rungnum]}"
}

# recursive grep / grep recursive
function grepr {
# NOTE: to allow this function to work in readonly directories, 
# ..... the "~" ($HOME) directory is used to write a temporary file.
# ..... On Windows systems, the default $HOME path is generally not set
# ..... correctly, resulting in errors when `grepr` is called. 
# ..... This can be resolved either by using CMD's mklink
# ..... to create a symbolic link in [cygwinDirectory]/home to the proper place
# ..... (on Windows 7 and up), or you can directly set $HOME in /etc/bashrc,
# ..... ~/export_local, or elsewhere that individual ".bashrc"s are likely to
# ..... source.
	location=$"." #"`pwd -P`"
	regex=$""
	findargs="-type f"
	dostring=""
	if (( $# < 1 )); then
		echo 'Recursive grep usage: grepr <regex> or grepr <location> <regex> [<args for find>]'
		echo 'With the simple invocation, find will receive -type f. With the full invocation, this must be specified if desired.'
		kill -INT $$
	elif [[ $# -eq 1 ]]; then
	# if we just got the one argument
		regex="$1"
		dostring="grep -R -n -H '$regex' . --color=always "
	else # (( $# > 1 )); then
	# if we got more than one argument
		location=$"$1"
		regex=$"$2"
		findargs=$"" 
		shift 2
		while [[ $# -gt 0 ]]; do
			if [[ "$1" == -type ]]; then
			# if we're dealing with the -type flag, assume it's followed by a letter:
				findargs=$"$findargs $1"
				shift
				findargs=$"$findargs $1" # find will choke if passed e.g. -type 'f' vs. -type f
			elif [[ "$1" == -* || "$1" == \! ]]; then
			# if component begins with '-' or is negator '!'
			# don't quote so it actually reads as a flag:
				findargs=$"$findargs $1"
			else
			# otherwise quote so that we don't get glob-expansion happening early:
				findargs=$"$findargs '$1'"
			fi
			shift
		done
		dostring=$"find $location $findargs -exec grep -n -H '$regex' {} --color=always \\;"
	fi
	# find $location $findargs -exec grep -H '$regex' {} --color=always \\\;
	fn=$"/tmp/`whoami`_grepr_`date +%s`.tmp"
	echo "$dostring" > "$fn"
	chmod u+x "$fn" # enable execution for current user
	. "$fn" # execute file in current shell
	rm -f "$fn"
}

# [ Complex alias for builtin `ps` command ]
function ps {
	if (( $# == 2 )) && [[ "$1" == "aux" ]]; then
		psResults=$"`command ps aux`"
		echo "$psResults" | awk 'NR==1'
		echo "$psResults" | grep "$2"
	else
		command ps "$@"
	fi
}

# [ Complex alias for git to add options depending on the specifc subcommand ]
function git {
	if (( $# > 0 )); then
		if [[ "$1" == "commit" ]]; then
		# if a commit was just made, show the author-information afterwards so
		# that misattributed commits can be caught before being pushed to repo:
			command git "$@"
			command git show | awk 'NR==2'
		elif [[ "$1" == "clone" ]]; then
			command git "$@" --recursive
		else
			command git "$@"
		fi
	else
		command git
	fi
}

# Write to the beginning of a file
function prepend {
	if (( $# < 2 )); then
		echo "Two or more arguments required. Usage: prepend <prefix> file1[ file2...]"
	else
		prefix=$"$1"
		shift # move past the prefix so all remaining params are files
		while (( $# > 0 )); do
			sed -i "1i $prefix" "$1"
			shift
		done
	fi
}

# Delete the contents of a file
function nuke {
	if (( $# < 1 )); then
		echo 'One or more arguments required. Useage: nuke file1[ file2...]'
		echo 'Overwrites file(s) with an empty regular file.'
		kill -INT $$		
	fi
	for a in "$@"; do
		rm "$a"
		touch "$a"
	done
}

# Uncompress tar'd files:
function untar {
	if (( $# < 1 )); then
		echo 'No arguments received. Usage: untar <archiveFile>'
	else
		tar -zxvf "$1"
		if (( $? != 0 )); then
			echo Unpack failed under gzip. Trying again with bzip2.
			tar -jxvf "$1"
		fi
	fi
}
  
# Remove vim lockfiles
function unlock {
	if (( $# < 1 )); then
		echo 'No arguments received. Usage: unlock <file>'
	else
		for arg in "$@"; do
		# ^ loop through arguments as needed
			rm "."$arg".swp"
		done
	fi
}

# Change current working directory to the absolute directory of a symlink
function cdl {
    cd "$(dirname "$(readlink "$1")")"
}

# Alias for cdl function (defined above)
function lcd {
	cdl "$@"
}

# Convert a Windows-style file-path to a linux-style one
function wcd {
	cd $(echo "$1" | sed 's/\\\\/\//g')
}

# Change current working directory to a parallel directory
function sis {
    cd ../"$1"
}

# [ Complex alias for builtin `du` command ]
function duc {
	# below, we ignore aliases on `du` with `command`
	if (( $# < 1 )); then
		command du -h -s *
	else
		command du -h "$@"
	fi
}

# Output a table of contents for a zip-file:
function toc {
	if (( $# < 1 )); then
		echo 'toc function - exports a table of contents for a zip-file'
		echo "\tUsage: toc <file>.zip"
	fi
	vim -c "w $1.toc" -c "q" "$1"
	echo "Saved toc to $1.toc"
}

function xviml {
# view the contents of an xml-file after formatting has been applied
	if (( $# < 1 )); then
		echo 'Format XML and open in vim. Saving afterwards optional. Usage: xviml <file>'
		kill -INT $$
	fi
	xmllint "$1" --format | vim -
}

function sviml {
# view the contents of an SQL-file after keywords have all been capped
	if (( $# < 1 )); then
		echo 'Format PostgreSQL and open in vim. Saving afterwards optional. Usage: sviml <file>'
		kill -INT $$
	fi
	# vim "$1" -c 'call ChangeSqlCase()'
	vim "$1" -c 'normal ggVG:call ChangeSqlCase()'
	# ^ gg goes to top
	# ^.. V starts selecting by line
	# ^.. G goes to bottom
	# ^.. Then we call a custom function to fix the case and hit enter
}

function jvimn {
# view the contents of a JSON-file after formatting has been applied
	if (( $# < 1 )); then
		echo 'Format JSON and open in vim. Saving afterwards optional. Useage: jvimn <file>'
		kill -INT $$
	fi
	python -m json.tool "$1" | vim -
}

function fnd {
# If given a single search-term, do a sliding search in the current directory 
	# assume contains-search first:
	term='*'"$1"'*' # potentially nonfinal
	if (( $# == 0 )) || (( $# > 2 )); then
		echo 'shortfind usage: fnd [-e] <term>'
		echo '-e -- exact match'
		kill -INT $$
	elif (( $# == 2 )); then
		if ! [[ "$@" = *-e* ]]; then
			echo -e "\nTo use two arguments with shortfind, one must be -e"
			echo 'For more information just use fnd by itself to show help'
			kill -INT $$
		elif [[ "-e" = $1 ]]; then
			term="$2"
		elif [[ "-e" = $2 ]]; then
			term="$1"
		fi
	fi
	command find . -iname "$term"
}


function c_d {
	if (( $# > 0 )) && [ "$1" != "-" ] && ! [ -d "$1" ]; then
		local parentDir=$(dirname "$1")
		echo "$1 is not a directory." 1>&2
		if [[ -d "$parentDir" ]] && [[ "$parentDir" != "." ]]; then
		# ^ dirname yields "." if passed the empty string. Since "." should
		# pretty invariably test as a valid directory, we check for this
		# separately. We can encounter this if the caller does a relative `cd`
		# like `cd 0` in a directory where there is no subdir called '0'
			echo  "Changing to parent dir instead." 1>&2
			command cd "$parentDir"
		fi
		return 1;
	else
		command cd "$@"
		return $?;
		# ^ `command` is transparent to operations encountering errors, so we
		# just go by what it tells us
	fi
}


# Shortcut for doing both `chown` and `chgrp`
function choth {
	usr="`whoami`"
	if (( $# > 1 )); then
		usr="$1"
		shift
	fi
	for arg in "$@"; do
		chown "$usr" "$arg"
		chgrp "$usr" "$arg"
	done
}


function ll {
	if (( $# < 1 )) || [[ "$1" = -* && $# -eq 1 ]]; then
	# if no arguments or only option-flags given, work on the current dir and
	# just add the "long" option:
		ls -l "$@"
	else
	# otherwise, assume caller does not care about the directory's contents but
	# instead wants to know about the file(s) themselves:
		ls -ld "$@"
	fi
}

unalias ll 2>/dev/null
