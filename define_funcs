#!/bin/bash
# define_funcs

# remember to source this BEFORE you try to export the stuff

function up {
	rungnum=1 # how many ladder-rungs to climb, default just 1 level if no args
	if (( $# > 0 )); then
		rungnum=$1 	
	fi
	gohere=""
	for ((i=0;i<${rungnum};i+=1)); do
		gohere="${gohere}../"
	done
	# alias up='cd `pwd -P`/..' #resolve symlinks and go up. 'cd -' is for going "back"
	cd "`pwd -P`/$gohere"
}

function grepr {
	location=$"." #"`pwd -P`"
	regex=$""
	findargs="-type f"
	if (( $# < 1 )); then
		echo 'Recursive grep usage: grepr <regex> or grepr <location> <regex> [<args for find>]'
		echo 'With the simple invocation, find will receive -type f. With the full invocation, this must be specified if desired.'
		kill -INT $$
	elif [[ $# -eq 1 ]]; then
	# if we just got the one argument
		regex="$1"
	else # (( $# > 1 )); then
	# if we got more than one argument
		location=$"$1"
		regex=$"$2"
		findargs=$"" 
		shift 2
		while [[ $# -gt 0 ]]; do
			if [[ "$1" == -type ]]; then
			# if we're dealing with the -type flag, assume it's followed by a letter:
				findargs=$"$findargs $1"
				shift
				findargs=$"$findargs $1" # find will choke if passed e.g. -type 'f' vs. -type f
			elif [[ "$1" == -* || "$1" == \! ]]; then
			# if component begins with '-' or is negator '!'
			# don't quote so it actually reads as a flag:
				findargs=$"$findargs $1"
			else
			# otherwise quote so that we don't get glob-expansion happening early:
				findargs=$"$findargs '$1'"
			fi
			shift
		done
	fi
	dostring=$"find $location $findargs -exec grep -H '$regex' {} --color=always \\;"
	# find $location $findargs -exec grep -H '$regex' {} --color=always \\\;
	fn="~/grepr_`date +%s`.tmp"
	echo $dostring > $fn 
	chmod u+x ~/fine
	. ~/fine
	# rm ~/fine
}

function unlock {
	if (( $# < 1 )); then
		echo 'No arguments received. Usage: unlock <file>'
	else
		for arg in "$@"; do
		# ^ loop through arguments as needed
			rm "."$arg".swp"
		done
	fi
}

function cdl {
    cd "$(dirname "$(readlink "$1")")"
}

function lcd {
	cdl "$@"
}

function sis {
    cd ../"$1"
}

function tarup {
	if (( $# > 1 )); then
		tar cvzf $*
	else
		tar cvzf "$1".tar "$1"
		# ^ this prevents that obnoxious and confounding
		# ^.. "cowardly refusing to create an empty archive" message
	fi
}

function xviml {
# view the contents of an xml-file after formatting has been applied
	if (( $# < 1 )); then
		echo 'Format XML and open in vim. Saving afterwards optional. Usage: xviml <file>'
		kill -INT $$
	fi
	xmllint "$1" --format | vim -
}

function sviml {
# view the contents of an SQL-file after keywords have all been capped
	if ( $# < 1 ); then
		echo 'Format PostgreSQL and open in vim. Saving afterwards optional. Usage: sviml <file>'
		kill -INT $$
	fi
	vim "$1" -c 'normal ggVGU'
	# ^ gg goes to top
	# ^.. V starts selecting by line
	# ^.. G goes to bottom
	# ^.. U is a custom mapping to do the SQL-capitalizing magic
}

