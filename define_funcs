#!/bin/bash
# define_funcs

# remember to source this BEFORE you try to export the stuff

function s3cmd {
	# define keys if needed:
	if [ -z "$AWS_SECRET_KEY" ]; then
		both=`gpg -o- ~/.aws/keys.gpg 2>/dev/null`
		export AWS_ACCESS_KEY=`echo "$both" | awk "NR==1"`
		export AWS_SECRET_KEY=`echo "$both" | awk "NR==2"`
	fi
	options=$"--access_key=$AWS_ACCESS_KEY --secret_key=$AWS_SECRET_KEY --config=~/.s3cfg"
	if (( $# == 2 )) && [ "$1" = "du" ]; then
		options="$options du $2"
		echo "$options" > options.tmp
		output=`command s3cmd $options 2>/dev/null`
		echo "$output" | cut -d ' ' -f 1 | sed -e 's/^/scale=2; /' -e 's/$/\/1024^2/' | bc | sed 's/$/ MB/'
	else
		options="$options ""$@"
		command s3cmd $options
	fi
}

function up {
	rungnum=1 # how many ladder-rungs to climb, default just 1 level if no args
	absprefix=$"." # the actual prefix to give to `cd`. Opts may modify.
	while getopts ":S" opt; do
		if [[ "$opt" == "S" ]]; then
			absprefix="`pwd -P`"
			shift # allow rungnum to be picked up as $1 below
		elif [[ "$opt" == '?' ]]; then
			echo 'up usage: up [-S] [levels]'
			echo 'levels specifies how many times to go up a directory.'
			echo -n '-S does an absolute ascent (resolves symbolic links in path)'
			kill -INT $$
		fi
	done
	if (( $# > 0 )); then
		rungnum=$1 	
	fi
	gohere=""
	for ((i=0;i<${rungnum};i+=1)); do
		gohere="${gohere}../"
	done
	cd "$absprefix/$gohere"
}

function grepr {
# NOTE: to allow this function to work in readonly directories, 
# ..... the "~" ($HOME) directory is used to write a temporary file.
# ..... On Windows systems, the default $HOME path is generally not set
# ..... correctly, resulting in errors when `grepr` is called. 
# ..... This can be resolved either by using CMD's mklink
# ..... to create a symbolic link in [cygwinDirectory]/home to the proper place
# ..... (on Windows 7 and up), or you can directly set $HOME in /etc/bashrc,
# ..... ~/export_local, or elsewhere that individual ".bashrc"s are likely to
# ..... source.
	location=$"." #"`pwd -P`"
	regex=$""
	findargs="-type f"
	if (( $# < 1 )); then
		echo 'Recursive grep usage: grepr <regex> or grepr <location> <regex> [<args for find>]'
		echo 'With the simple invocation, find will receive -type f. With the full invocation, this must be specified if desired.'
		kill -INT $$
	elif [[ $# -eq 1 ]]; then
	# if we just got the one argument
		regex="$1"
	else # (( $# > 1 )); then
	# if we got more than one argument
		location=$"$1"
		regex=$"$2"
		findargs=$"" 
		shift 2
		while [[ $# -gt 0 ]]; do
			if [[ "$1" == -type ]]; then
			# if we're dealing with the -type flag, assume it's followed by a letter:
				findargs=$"$findargs $1"
				shift
				findargs=$"$findargs $1" # find will choke if passed e.g. -type 'f' vs. -type f
			elif [[ "$1" == -* || "$1" == \! ]]; then
			# if component begins with '-' or is negator '!'
			# don't quote so it actually reads as a flag:
				findargs=$"$findargs $1"
			else
			# otherwise quote so that we don't get glob-expansion happening early:
				findargs=$"$findargs '$1'"
			fi
			shift
		done
	fi
	dostring=$"find $location $findargs -exec grep -H '$regex' {} --color=always \\;"
	# find $location $findargs -exec grep -H '$regex' {} --color=always \\\;
	fn=$"grepr_`date +%s`.tmp"
	echo "$dostring" > "$fn"
	chmod u+x "$fn" # enable execution for current user
	. "$fn" # execute file in current shell
	rm "$fn"
}

function ps {
	if (( $# == 2 )) && [[ "$1" == "aux" ]]; then
		psResults=$"`command ps aux`"
		echo "$psResults" | awk 'NR==1'
		echo "$psResults" | grep "$2"
	else
		command ps "$@"
	fi
}

function prepend {
	if (( $# < 2 )); then
		echo Two or more arguments required. Usage: prepend <prefix> file1[ file2...]
	else
		prefix=$"$1"
		shift # move past the prefix so all remaining params are files
		while (( $# > 0 )); do
			sed -i "1i $prefix" $1
			shift
		done
	fi
}

function nuke {
	if (( $# < 1 )); then
		echo 'One or more arguments required. Useage: nuke file1[ file2...]'
		echo 'Overwrites file(s) with an empty regular file.'
		kill -INT $$		
	fi
	for a in "$@"; do
		rm "$a"
		touch "$a"
	done
}

function untar {
	if (( $# < 1 )); then
		echo 'No arguments received. Usage: untar <archiveFile>'
	else
		tar -zxvf "$1"
		if (( $? != 0 )); then
			echo Unpack failed under gzip. Trying again with bzip2.
			tar -jxvf "$1"
		fi
	fi
}
  
function unlock {
	if (( $# < 1 )); then
		echo 'No arguments received. Usage: unlock <file>'
	else
		for arg in "$@"; do
		# ^ loop through arguments as needed
			rm "."$arg".swp"
		done
	fi
}

function cdl {
    cd "$(dirname "$(readlink "$1")")"
}

function lcd {
	cdl "$@"
}

function wcd {
	cd $(echo "$1" | sed 's/\\\\/\//g')
}

function sis {
    cd ../"$1"
}

function duc {
	# below, we ignore aliases on `du` with `command`
	if (( $# < 1 )); then
		command du -h -s *
	else
		command du -h "$@"
	fi
}

function xviml {
# view the contents of an xml-file after formatting has been applied
	if (( $# < 1 )); then
		echo 'Format XML and open in vim. Saving afterwards optional. Usage: xviml <file>'
		kill -INT $$
	fi
	xmllint "$1" --format | vim -
}

function sviml {
# view the contents of an SQL-file after keywords have all been capped
	if (( $# < 1 )); then
		echo 'Format PostgreSQL and open in vim. Saving afterwards optional. Usage: sviml <file>'
		kill -INT $$
	fi
	# vim "$1" -c 'call ChangeSqlCase()'
	vim "$1" -c 'normal ggVG:call ChangeSqlCase()'
	# ^ gg goes to top
	# ^.. V starts selecting by line
	# ^.. G goes to bottom
	# ^.. Then we call a custom function to fix the case and hit enter
}

function shortfind {
# If given a single search-term, do a sliding search in the current directory 
# otherwise works like standard find
	if (( $# == 0 )); then
		kill -INT $$
	elif (( $# != 1 )); then
		command find $@
	else
		term='*'"$1"'*'
		command find . -iname "$term"
	fi
}
